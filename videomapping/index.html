<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8" />
  <title>Simple Projection Mapping POC</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB" crossorigin="anonymous">
  <style>
    .material-symbols-outlined {
      display: block;
      font-variation-settings:
      'FILL' 0,
      'wght' 400,
      'GRAD' 0,
      'opsz' 24
    }
  </style>
  <style>
    * {
      -ms-overflow-style: none; /* IE 10+ / Edge Legacy */
      scrollbar-width: none;    /* Firefox */
    }

    *::-webkit-scrollbar {
      display: none;            /* Chrome, Safari, Edge */
    }
    html, body {
        margin: 0;
        padding: 0;
        background: #111;
        color: #eee;
        font-family: system-ui, sans-serif;
        height: 100vh;
        width: 100vw;
        max-width: 100vw;
        max-height: 100vh;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    #app {
        position: relative;
        height: 100%;
        width: 100%;
        max-width: 100%;
        max-height: 100%;
        overflow: hidden;
        border: none;
        background: #000;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
        overflow: hidden;
    }

    #glcanvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    /* Video is alleen bron, niet zichtbaar */
    #video {
      display: none;
    }

    /* #playHint {
      opacity: 0;
    }
    #playHint:hover {
      opacity: 1;
    } */

    .handle {
        position: absolute;
        width: 3rem;
        height: 3rem;
        border-radius: 50%;
        background: rgba(255, 0, 0, 0.9);
        border: 2px solid #fff;
        transform: translate(-50%, -50%);
        cursor: move;
        box-shadow: 0 0 6px rgba(0,0,0,0.8);
        z-index: 10;
        user-select: none;
        opacity: 0;
    }

    .handle:hover {
        background: rgba(235, 255, 80, 0.5);
        opacity: 1;
    }

    #info {
      position: absolute;
      left: 10px;
      bottom: 10px;
      background: rgba(0,0,0,0.6);
      padding: 6px 10px;
      font-size: 12px;
      border-radius: 4px;
      pointer-events: none;
    }

    /* #playHint {
      position: absolute;
      right: 10px;
      bottom: 10px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.2);
      padding: 4px 8px;
      font-size: 11px;
      border-radius: 4px;
    } */

    #playBtn {
      padding: 3px 8px;
      margin-left: 6px;
      font-size: 11px;
      cursor: pointer;
      background: #0b84ff;
      border: none;
      color: #fff;
      border-radius: 3px;
    }

    #playBtn:hover {
      background: #46a3ff;
    }

    #controls {
      position: absolute;
      top: 0px;
      left: 0px;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: stretch;
      font-size: 12px;
      max-width: 360px;
      max-height: calc(100vh - 2rem);
      overflow: hidden;
      opacity: 1;
      transition: opacity 0.2s ease;
    }
    #controls:hover {
      opacity: 1;
    }

    .controls-top {
      display: flex;
      align-items: center;
      justify-content: space-between;
      min-height: fit-content;
      background: rgba(0, 0, 0, 0.25);
      border: 1px solid rgba(255, 255, 255, 0.2);
      padding: 0.5rem;
      border-radius: 4px;
      gap: 10px;
      max-width: 100%;
      overflow: hidden;
      backdrop-filter: blur(6px);
    }
    #contentList{
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      max-width: 100%;
      overflow: hidden;
      overflow-y: scroll;
    }

    .link-all-toggle {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      font-size: 11px;
      color: #ddd;
      white-space: nowrap;
      background: transparent;
      border: none;
      cursor: pointer;
      padding: 4px;
      border-radius: 4px;
      transition: background 0.2s ease;
    }

    .link-all-toggle:hover {
      background: rgba(255, 255, 255, 0.08);
    }

    .history-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 4px;
      background: transparent;
      border: none;
      cursor: pointer;
      border-radius: 4px;
      transition: background 0.2s ease;
    }

    .history-btn:hover {
      background: rgba(255, 255, 255, 0.08);
    }

    .history-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .add-content-btn {
      padding: 3px 8px;
      font-size: 11px;
      cursor: pointer;
      background: #22c55e;
      border: none;
      color: #0b0b0b;
      border-radius: 3px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .control-block {
      padding: 0.5rem;
      max-width: 100%;
      min-height: fit-content;
      overflow: hidden;
      background: rgba(0, 0, 0, 0.25);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      backdrop-filter: blur(6px);
    }

    .control-block-header {
      max-width: 100%;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .control-title {
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #9bd4ff;
    }

    .control-remove-btn {
      background: transparent;
      border: none;
      color: #ff8c8c;
      font-size: 16px;
      line-height: 1;
      cursor: pointer;
      padding: 0 2px;
    }
    .control-remove-btn:hover {
      color: #ff5555;
    }

    .control-row {
      max-width: 100%;
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
      margin-top: 4px;
    }

    #controls label,
    .control-label {
      font-size: 11px;
      color: #ddd;
    }

    .control-block input[type="text"] {
      background: #111;
      border: 1px solid #555;
      border-radius: 3px;
      padding: 2px 4px;
      color: #fff;
      width: 90px;
    }

    .control-block input[type="file"] {
      font-size: 11px;
      color: #ccc;
    }

    .control-block button,
    #playBtn {
      padding: 3px 8px;
      font-size: 11px;
      cursor: pointer;
      background: #0b84ff;
      border: none;
      color: #fff;
      border-radius: 3px;
    }

    .control-block button.secondary {
      background: #444;
    }

    .control-block button.danger {
      background: #d72638;
    }

    .control-block input.invalid {
      border-color: #ff5b5b71;
    }

    /* Animations */
    .border-rainbow{
        animation: border-angle-rotate 2s infinite linear;
        border: 0.5rem solid transparent;
        background: linear-gradient(black, black) padding-box,
        conic-gradient(
            from var(--border-angle),
            oklch(100% 100% 0deg),
            oklch(100% 100% 45deg),
            oklch(100% 100% 90deg),
            oklch(100% 100% 135deg),
            oklch(100% 100% 180deg),
            oklch(100% 100% 225deg),
            oklch(100% 100% 270deg),
            oklch(100% 100% 315deg),
            oklch(100% 100% 360deg)
            )
            border-box;
        
    }
    @keyframes border-angle-rotate {
        from { --border-angle: 0deg; }
        to { --border-angle: 360deg; }
    }
    @property --border-angle {
        syntax: "<angle>";
        initial-value: 0deg;
        inherits: false;
    }
  </style>
</head>
<body>
  <div id="app">
    <canvas id="glcanvas"></canvas>

    <div id="controls">
      <div class="controls-top">
        <div class="control-title">Content blokken</div>
        <div style="display: flex; align-items: center; gap: 6px;">
          <button id="undoBtn" type="button" class="history-btn bg-transparent p-1" aria-label="Ongedaan maken" disabled>
            <span class="material-symbols-outlined text-light">undo</span>
          </button>
          <button id="redoBtn" type="button" class="history-btn bg-transparent p-1" aria-label="Opnieuw" disabled>
            <span class="material-symbols-outlined text-light">redo</span>
          </button>
        <button id="linkAllToggle" type="button" class="link-all-toggle bg-transparent p-1" aria-label="Lagen koppelen" aria-pressed="false">
          <span class="material-symbols-outlined text-light" id="linkAllIcon">link</span>
        </button>
        </div>
        <button id="addContentBtn" type="button" class="add-content-btn bg-transparent p-1 rounded"><span class="material-symbols-outlined text-light">add</span></button>
      </div>
      <div id="contentList"></div>
    </div>



    /* <div id="playHint">
      Als de video niet speelt:
      <button id="playBtn" type="button">Play video</button>
    </div> */
  </div>

  <!-- three.js via CDN -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    const app = document.getElementById('app');
    const canvas = document.getElementById('glcanvas');
    const contentList = document.getElementById('contentList');
    const addContentBtn = document.getElementById('addContentBtn');
    const playBtn = document.getElementById('playBtn');
    const linkAllToggle = document.getElementById('linkAllToggle');
    const linkAllIcon = document.getElementById('linkAllIcon');
    const undoBtn = document.getElementById('undoBtn');
    const redoBtn = document.getElementById('redoBtn');

    let width = app.clientWidth;
    let height = app.clientHeight;

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    const devicePixelRatio = Math.min(2, window.devicePixelRatio || 1);
    renderer.setPixelRatio(devicePixelRatio);
    renderer.setSize(width, height, false);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    const textureLoader = new THREE.TextureLoader();

    const PLACEHOLDER_IMAGE = '';
    let sharedPlaceholderTexture = null;
    let placeholderLoadStarted = false;
    let placeholderLoadFailed = false;
    const placeholderWaiters = [];

    function startPlaceholderLoad() {
      if (placeholderLoadStarted) return;
      placeholderLoadStarted = true;
      textureLoader.load(
        PLACEHOLDER_IMAGE,
        texture => {
          texture.minFilter = THREE.LinearFilter;
          texture.magFilter = THREE.LinearFilter;
          sharedPlaceholderTexture = texture;
          const callbacks = placeholderWaiters.splice(0, placeholderWaiters.length);
          callbacks.forEach(cb => cb(texture));
        },
        undefined,
        error => {
          placeholderLoadFailed = true;
          console.error('Kon placeholder niet laden:', error);
          placeholderWaiters.length = 0;
        }
      );
    }

    function onPlaceholderReady(callback) {
      if (sharedPlaceholderTexture) {
        callback(sharedPlaceholderTexture);
      } else if (!placeholderLoadFailed) {
        placeholderWaiters.push(callback);
        startPlaceholderLoad();
      }
    }

    startPlaceholderLoad();

    const EFFECT_OPTIONS = [
      { value: '', label: 'Geen effect' },
      { value: 'border-rainbow-8', label: 'Border Rainbow 8px' },
      { value: 'border-rainbow-16', label: 'Border Rainbow 16px' },
      { value: 'border-rainbow-32', label: 'Border Rainbow 32px' },
      { value: 'border-rainbow-64', label: 'Border Rainbow 64px' }

    ];

    const EFFECT_DEFINITIONS = {
      'border-rainbow-8': {
        size: 5120,
        draw(ctx, time) {
          const { width } = ctx.canvas;
          const height = ctx.canvas.height;
          const borderWidthPx = 8;
          const minDim = Math.min(width, height);
          ctx.clearRect(0, 0, width, height);
          let gradient;
          const rotation = (time * 0.001) % (Math.PI * 2);
          if (typeof ctx.createConicGradient === 'function') {
            gradient = ctx.createConicGradient(rotation, width / 2, height / 2);
          } else {
            gradient = ctx.createLinearGradient(0, 0, width, height);
          }
          gradient.addColorStop(0.0, '#ff5f6d');
          gradient.addColorStop(0.17, '#ffc371');
          gradient.addColorStop(0.33, '#47c6ff');
          gradient.addColorStop(0.5, '#ac6cff');
          gradient.addColorStop(0.67, '#53f3d3');
          gradient.addColorStop(0.83, '#f6d365');
          gradient.addColorStop(1.0, '#ff5f6d');
          ctx.fillStyle = 'transparent';
          ctx.fillRect(0, 0, width, height);
          ctx.strokeStyle = gradient;
          ctx.lineWidth = Math.min(borderWidthPx, width * 0.15);
          ctx.lineCap = 'round';
          const inset = minDim * 0.00;
          const rectWidth = Math.max(0, width - inset * 2);
          const rectHeight = Math.max(0, height - inset * 2);
          ctx.strokeRect(inset, inset, rectWidth, rectHeight);
          ctx.fillStyle = 'rgba(0,0,0,0.0)';
          const innerInset = minDim * 0.0;
          const innerWidth = Math.max(0, width - innerInset * 2);
          const innerHeight = Math.max(0, height - innerInset * 2);
          ctx.fillRect(innerInset, innerInset, innerWidth, innerHeight);
        }
      },
      'border-rainbow-16': {
          size: 5120,
          draw(ctx, time) {
            const { width } = ctx.canvas;
            const height = ctx.canvas.height;
            const borderWidthPx = 16;
            const minDim = Math.min(width, height);
            ctx.clearRect(0, 0, width, height);
            let gradient;
            const rotation = (time * 0.001) % (Math.PI * 2);
            if (typeof ctx.createConicGradient === 'function') {
              gradient = ctx.createConicGradient(rotation, width / 2, height / 2);
            } else {
              gradient = ctx.createLinearGradient(0, 0, width, height);
            }
            gradient.addColorStop(0.0, '#ff5f6d');
            gradient.addColorStop(0.17, '#ffc371');
            gradient.addColorStop(0.33, '#47c6ff');
            gradient.addColorStop(0.5, '#ac6cff');
            gradient.addColorStop(0.67, '#53f3d3');
            gradient.addColorStop(0.83, '#f6d365');
            gradient.addColorStop(1.0, '#ff5f6d');
            ctx.fillStyle = 'transparent';
            ctx.fillRect(0, 0, width, height);
            ctx.strokeStyle = gradient;
            ctx.lineWidth = Math.min(borderWidthPx, width * 0.15);
            ctx.lineCap = 'round';
            const inset = minDim * 0.00;
            const rectWidth = Math.max(0, width - inset * 2);
            const rectHeight = Math.max(0, height - inset * 2);
            ctx.strokeRect(inset, inset, rectWidth, rectHeight);
            ctx.fillStyle = 'rgba(0,0,0,0.0)';
            const innerInset = minDim * 0.0;
            const innerWidth = Math.max(0, width - innerInset * 2);
            const innerHeight = Math.max(0, height - innerInset * 2);
            ctx.fillRect(innerInset, innerInset, innerWidth, innerHeight);
          }
        },
      'border-rainbow-32': {
          size: 5120,
          draw(ctx, time) {
            const { width } = ctx.canvas;
            const height = ctx.canvas.height;
            const borderWidthPx = 32;
            const minDim = Math.min(width, height);
            ctx.clearRect(0, 0, width, height);
            let gradient;
            const rotation = (time * 0.001) % (Math.PI * 2);
            if (typeof ctx.createConicGradient === 'function') {
              gradient = ctx.createConicGradient(rotation, width / 2, height / 2);
            } else {
              gradient = ctx.createLinearGradient(0, 0, width, height);
            }
            gradient.addColorStop(0.0, '#ff5f6d');
            gradient.addColorStop(0.17, '#ffc371');
            gradient.addColorStop(0.33, '#47c6ff');
            gradient.addColorStop(0.5, '#ac6cff');
            gradient.addColorStop(0.67, '#53f3d3');
            gradient.addColorStop(0.83, '#f6d365');
            gradient.addColorStop(1.0, '#ff5f6d');
            ctx.fillStyle = 'transparent';
            ctx.fillRect(0, 0, width, height);
            ctx.strokeStyle = gradient;
            ctx.lineWidth = Math.min(borderWidthPx, width * 0.15);
            ctx.lineCap = 'round';
            const inset = minDim * 0.00;
            const rectWidth = Math.max(0, width - inset * 2);
            const rectHeight = Math.max(0, height - inset * 2);
            ctx.strokeRect(inset, inset, rectWidth, rectHeight);
            ctx.fillStyle = 'rgba(0,0,0,0.0)';
            const innerInset = minDim * 0.0;
            const innerWidth = Math.max(0, width - innerInset * 2);
            const innerHeight = Math.max(0, height - innerInset * 2);
            ctx.fillRect(innerInset, innerInset, innerWidth, innerHeight);
          }
        },
      'border-rainbow-64': {
          size: 5120,
          draw(ctx, time) {
            const { width } = ctx.canvas;
            const height = ctx.canvas.height;
            const borderWidthPx = 64;
            const minDim = Math.min(width, height);
            ctx.clearRect(0, 0, width, height);
            let gradient;
            const rotation = (time * 0.001) % (Math.PI * 2);
            if (typeof ctx.createConicGradient === 'function') {
              gradient = ctx.createConicGradient(rotation, width / 2, height / 2);
            } else {
              gradient = ctx.createLinearGradient(0, 0, width, height);
            }
            gradient.addColorStop(0.0, '#ff5f6d');
            gradient.addColorStop(0.17, '#ffc371');
            gradient.addColorStop(0.33, '#47c6ff');
            gradient.addColorStop(0.5, '#ac6cff');
            gradient.addColorStop(0.67, '#53f3d3');
            gradient.addColorStop(0.83, '#f6d365');
            gradient.addColorStop(1.0, '#ff5f6d');
            ctx.fillStyle = 'transparent';
            ctx.fillRect(0, 0, width, height);
            ctx.strokeStyle = gradient;
            ctx.lineWidth = Math.min(borderWidthPx, width * 0.15);
            ctx.lineCap = 'round';
            const inset = minDim * 0.00;
            const rectWidth = Math.max(0, width - inset * 2);
            const rectHeight = Math.max(0, height - inset * 2);
            ctx.strokeRect(inset, inset, rectWidth, rectHeight);
            ctx.fillStyle = 'rgba(0,0,0,0.0)';
            const innerInset = minDim * 0.0;
            const innerWidth = Math.max(0, width - innerInset * 2);
            const innerHeight = Math.max(0, height - innerInset * 2);
            ctx.fillRect(innerInset, innerInset, innerWidth, innerHeight);
          }
        }
    };

    const ANIMATION_OPTIONS = [
      { value: '', label: 'Geen animatie' },
      { value: 'conic-grid-shift', label: 'Conic grid shift' }
    ];

    const ANIMATION_DEFINITIONS = {
      'conic-grid-shift': {
        size: 2048,
        maxSize: 4096,
        duration: 12000,
        draw(ctx, timeMs) {
          const { width, height } = ctx.canvas;
          const duration = 12000;
          const t = ((timeMs % duration) + duration) % duration / duration;
          const unit = Math.max(Math.min(width, height) * 0.025, 8);
          const keyframes = [
            { p: 0.0, values: [0, 0, 1, 2, 3] },
            { p: 0.075, values: [0, 0, 1, 2, 3] },
            { p: 0.125, values: [0, 1, 0, 3, 2] },
            { p: 0.20, values: [0, 1, 0, 3, 2] },
            { p: 0.25, values: [0, -1, -2, 5, 4] },
            { p: 0.325, values: [0, -1, -2, 5, 4] },
            { p: 0.375, values: [0, 1, -4, 7, 2] },
            { p: 0.45, values: [0, 1, -4, 7, 2] },
            { p: 0.50, values: [0, -2, -5, 8, 5] },
            { p: 0.575, values: [0, -2, -5, 8, 5] },
            { p: 0.625, values: [0, -3, -4, 7, 6] },
            { p: 0.70, values: [0, -3, -4, 7, 6] },
            { p: 0.75, values: [0, -1, -2, 5, 4] },
            { p: 0.825, values: [0, -1, -2, 5, 4] },
            { p: 0.875, values: [0, -3, 0, 3, 6] },
            { p: 0.95, values: [0, -3, 0, 3, 6] },
            { p: 1.0, values: [0, 0, 1, 2, 3] }
          ];

          const lerp = (a, b, k) => a + (b - a) * k;
          const sampleFrame = (frames, tNorm) => {
            let prev = frames[frames.length - 1];
            let next = frames[0];
            for (let i = 0; i < frames.length; i++) {
              if (tNorm >= frames[i].p) {
                prev = frames[i];
                next = frames[(i + 1) % frames.length];
              }
            }
            const span = (next.p - prev.p + 1) % 1 || 1;
            const localT = ((tNorm - prev.p + 1) % 1) / span;
            return prev.values.map((v, idx) => lerp(v, next.values[idx], localT));
          };

          const offsets = sampleFrame(keyframes, t);
          const rotation = (timeMs / duration) * Math.PI * 2;
          const palette = ['#1d351d', '#325632', '#8b181d', '#6f0f11'];
          ctx.clearRect(0, 0, width, height);

          const drawRadialLayer = () => {
            const step = unit;
            const radius = unit * 0.6;
            for (let y = -step; y < height + step; y += step) {
              for (let x = -step; x < width + step; x += step) {
                const cx = x + offsets[0] * unit + step / 2;
                const cy = y + offsets[0] * unit + step / 2;
                const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, radius);
                grad.addColorStop(0, 'rgba(255,255,255,0.06)');
                grad.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = grad;
                ctx.fillRect(cx - step / 2, cy - step / 2, step, step);
              }
            }
          };

          const drawConicLayer = (layerIndex, color, rotationOffset) => {
            const step = unit * 4;
            for (let y = -step; y < height + step; y += step) {
              for (let x = -step; x < width + step; x += step) {
                const cx = x + offsets[layerIndex + 1] * unit + step / 2;
                const cy = y + offsets[layerIndex + 1] * unit + step / 2;
                const grad = typeof ctx.createConicGradient === 'function'
                  ? ctx.createConicGradient(rotation + rotationOffset, cx, cy)
                  : ctx.createLinearGradient(cx - step / 2, cy - step / 2, cx + step / 2, cy + step / 2);
                grad.addColorStop(0.0, 'transparent');
                grad.addColorStop(0.75, 'transparent');
                grad.addColorStop(0.75, color);
                grad.addColorStop(1.0, color);
                ctx.fillStyle = grad;
                ctx.fillRect(cx - step / 2, cy - step / 2, step, step);
              }
            }
          };

          drawRadialLayer();
          palette.forEach((color, idx) => {
            drawConicLayer(idx, color, idx * 0.4);
          });
        }
      }
    };

    const camera = new THREE.OrthographicCamera(
      0,
      width,
      height,
      0,
      -10,
      10
    );
    camera.position.z = 5;

    const targetUVs = [
      { u: 0, v: 1 },
      { u: 1, v: 1 },
      { u: 0, v: 0 },
      { u: 1, v: 0 }
    ];

    const BASE_COLOR_PALETTE = ['#00c8ff', '#ff5470', '#facc15', '#34d399', '#c084fc', '#f97316'];
    const DEFAULT_COLOR = 'transparent';
    const STORAGE_KEY = 'videomapping_state_v1';
    let isRestoring = false;

    const surfaces = new Map();
    const surfaceOrder = [];
    let surfaceCounter = 0;
    let linkAllSurfaces = false;
    const HISTORY_LIMIT = 10;
    let historyEntries = [];
    let historyIndex = -1;
    let historyDBPromise = null;
    let skipHistoryPush = false;

    function getHistoryDB() {
      if (historyDBPromise) return historyDBPromise;
      historyDBPromise = new Promise((resolve, reject) => {
        const request = indexedDB.open('videomapping-history', 1);
        request.onupgradeneeded = () => {
          const db = request.result;
          if (!db.objectStoreNames.contains('kv')) {
            db.createObjectStore('kv', { keyPath: 'key' });
          }
        };
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
      return historyDBPromise;
    }

    async function readHistoryState() {
      try {
        const db = await getHistoryDB();
        return await new Promise((resolve, reject) => {
          const tx = db.transaction('kv', 'readonly');
          const store = tx.objectStore('kv');
          const req = store.get('history');
          req.onsuccess = () => {
            if (req.result && req.result.value) {
              resolve(req.result.value);
            } else {
              resolve({ entries: [], index: -1 });
            }
          };
          req.onerror = () => reject(req.error);
        });
      } catch (err) {
        console.warn('Geschiedenis lezen mislukt:', err);
        return { entries: [], index: -1 };
      }
    }

    async function writeHistoryState(state) {
      try {
        const db = await getHistoryDB();
        await new Promise((resolve, reject) => {
          const tx = db.transaction('kv', 'readwrite');
          const store = tx.objectStore('kv');
          store.put({ key: 'history', value: state });
          tx.oncomplete = resolve;
          tx.onerror = () => reject(tx.error);
        });
      } catch (err) {
        console.warn('Geschiedenis opslaan mislukt:', err);
      }
    }

    function updateHistoryButtons() {
      if (undoBtn) undoBtn.disabled = historyIndex <= 0;
      if (redoBtn) redoBtn.disabled = historyIndex === -1 || historyIndex >= historyEntries.length - 1;
    }

    function serializeSurfaceForHistory(surface) {
      const data = surface && surface.geometry ? serializeSurface(surface) : { ...(surface || {}) };
      if (data.media === 'video' || data.media === 'image') {
        data.media = 'color';
        data.contentType = 'color';
        data.videoUrl = '';
        data.videoLabel = '';
        data.imageUrl = '';
        data.imageLabel = '';
      }
      return data;
    }

    function buildHistorySnapshot() {
      return {
        width,
        height,
        linkAllSurfaces,
        order: [...surfaceOrder],
        surfaces: [...surfaces.values()].map(serializeSurfaceForHistory)
      };
    }

    async function pushHistorySnapshot(stateOverride) {
      const snapshot = stateOverride
        ? {
            width: stateOverride.width,
            height: stateOverride.height,
            linkAllSurfaces: stateOverride.linkAllSurfaces,
            order: Array.isArray(stateOverride.order) ? [...stateOverride.order] : [...surfaceOrder],
            surfaces: Array.isArray(stateOverride.surfaces)
              ? stateOverride.surfaces.map(s => serializeSurfaceForHistory(s))
              : [...surfaces.values()].map(serializeSurfaceForHistory)
          }
        : buildHistorySnapshot();
      try {
        historyEntries = historyEntries.slice(0, historyIndex + 1);
        historyEntries.push(snapshot);
        while (historyEntries.length > HISTORY_LIMIT) {
          historyEntries.shift();
        }
        historyIndex = historyEntries.length - 1;
        await writeHistoryState({ entries: historyEntries, index: historyIndex });
        updateHistoryButtons();
      } catch (err) {
        console.warn('Snapshot toevoegen aan geschiedenis mislukt:', err);
      }
    }

    async function loadHistoryFromDB() {
      if (historyEntries.length > 0) {
        updateHistoryButtons();
        return;
      }
      const state = await readHistoryState();
      historyEntries = Array.isArray(state.entries) ? state.entries : [];
      historyIndex = typeof state.index === 'number' ? state.index : historyEntries.length - 1;
      updateHistoryButtons();
    }

    function applyHistorySnapshot(snapshot) {
      if (!snapshot || !Array.isArray(snapshot.order) || !Array.isArray(snapshot.surfaces)) return;
      const previousSaveFlag = isRestoring;
      isRestoring = true;
      [...surfaces.keys()].forEach(id => removeSurface(id, true));
      surfaceOrder.length = 0;
      linkAllSurfaces = !!snapshot.linkAllSurfaces;
      syncLinkAllToggle();
      snapshot.order.forEach(id => {
        const data = snapshot.surfaces.find(s => s.id === id);
        const s = createSurface({
          colorHex: data && data.colorHex ? data.colorHex : DEFAULT_COLOR,
          fitMode: data && data.fitMode ? data.fitMode : 'cover'
        });
        if (!s) return;
        if (data) {
          applySavedSurfaceData(s, data);
        }
      });
      isRestoring = previousSaveFlag;
      refreshSurfaceTitles();
      refreshSurfaceOrdering();
      refreshSurfaceList();
      skipHistoryPush = true;
      saveState();
    }

    function undoHistory() {
      if (historyIndex <= 0) return;
      historyIndex -= 1;
      const snapshot = historyEntries[historyIndex];
      applyHistorySnapshot(snapshot);
      writeHistoryState({ entries: historyEntries, index: historyIndex });
      updateHistoryButtons();
    }

    function redoHistory() {
      if (historyIndex === -1 || historyIndex >= historyEntries.length - 1) return;
      historyIndex += 1;
      const snapshot = historyEntries[historyIndex];
      applyHistorySnapshot(snapshot);
      writeHistoryState({ entries: historyEntries, index: historyIndex });
      updateHistoryButtons();
    }

    loadHistoryFromDB();

    function syncLinkAllToggle() {
      if (!linkAllToggle || !linkAllIcon) return;
      linkAllToggle.setAttribute('aria-pressed', linkAllSurfaces ? 'true' : 'false');
      linkAllIcon.textContent = linkAllSurfaces ? 'link_off' : 'link';
    }

    syncLinkAllToggle();

    function worldToDom(x, y) {
      return {
        left: x,
        top: height - y
      };
    }

    function createVideoElement() {
      const videoEl = document.createElement('video');
      videoEl.autoplay = false;
      videoEl.loop = true;
      videoEl.muted = true;
      videoEl.playsInline = true;
      videoEl.crossOrigin = 'anonymous';
      videoEl.style.display = 'none';
      app.appendChild(videoEl);
      return videoEl;
    }

    function createVideoTexture(element) {
      const texture = new THREE.VideoTexture(element);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.wrapS = THREE.ClampToEdgeWrapping;
      texture.wrapT = THREE.ClampToEdgeWrapping;
      texture.format = THREE.RGBAFormat;
      texture.premultiplyAlpha = false;
      return texture;
    }

    function createShaderMaterial(initialTexture, matrix) {
      return new THREE.ShaderMaterial({
        uniforms: {
          map: { value: initialTexture },
          homography: { value: matrix },
          gridHomography: { value: matrix.clone() },
          gridEnabled: { value: true },
          gridLines: { value: 10 },
          gridLineWidth: { value: 3 },
          gridColor: { value: new THREE.Color(0xffffff) },
          surfaceWidth: { value: 1 },
          surfaceHeight: { value: 1 }
        },
        vertexShader: `
          attribute vec2 localUV;
          varying vec2 vWorld;
          varying vec2 vLocalUV;
          void main() {
            vWorld = position.xy;
            vLocalUV = localUV;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform sampler2D map;
          uniform mat3 homography;
          uniform mat3 gridHomography;
          uniform bool gridEnabled;
          uniform float gridLines;
          uniform float gridLineWidth;
          uniform vec3 gridColor;
          uniform float surfaceWidth;
          uniform float surfaceHeight;
          varying vec2 vWorld;
          varying vec2 vLocalUV;

          void main() {
            vec3 uvw = homography * vec3(vWorld, 1.0);
            float w = uvw.z;
            if (abs(w) < 1e-6) discard;
            vec2 uv = uvw.xy / w;
            bool inRange = uv.x >= 0.0 && uv.x <= 1.0 && uv.y >= 0.0 && uv.y <= 1.0;
            vec4 texColor = inRange ? texture2D(map, uv) : vec4(0.0);
            if (gridEnabled) {
              vec3 guvw = gridHomography * vec3(vWorld, 1.0);
              float gw = guvw.z;
              if (abs(gw) > 1e-6) {
                vec2 guv = guvw.xy / gw;
                float lines = max(gridLines, 1.0);
                float spacingU = 1.0 / lines;
                float spacingV = 1.0 / lines;
                float posU = mod(guv.x, spacingU);
                float posV = mod(guv.y, spacingV);
                float distU = min(posU, spacingU - posU);
                float distV = min(posV, spacingV - posV);
                float minSpacing = min(spacingU, spacingV);
                float halfW = minSpacing * 0.49;
                float userHalfW = (max(gridLineWidth, 0.0) / 100.0) * minSpacing;
                halfW = min(halfW, userHalfW);
                float aa = max(fwidth(guv.x), fwidth(guv.y));
                float edge = min(distU, distV);
                float alpha = 1.0 - smoothstep(halfW - aa, halfW + aa, edge);
                if (alpha > 0.0) {
                  gl_FragColor = vec4(gridColor, alpha);
                  return;
                }
              }
            }
            gl_FragColor = texColor;
          }
        `,
        side: THREE.DoubleSide,
        transparent: true,
        alphaTest: 0,
        depthTest: false,
        depthWrite: false
      });
    }

    function normalizeHex(value) {
      if (!value) return null;
      if (value.trim().toLowerCase() === 'transparent') return 'transparent';
      const hex = value.trim().replace(/^#/, '');
      if (/^[0-9a-fA-F]{6}$/.test(hex)) {
        return `#${hex.toLowerCase()}`;
      }
      return null;
    }

    function createColorTexture(hex) {
      if (hex === 'transparent') {
        const data = new Uint8Array([0, 0, 0, 0]);
        const texture = new THREE.DataTexture(data, 1, 1, THREE.RGBAFormat);
        texture.needsUpdate = true;
        return texture;
      }
      const color = new THREE.Color(hex);
      const data = new Uint8Array([
        Math.round(color.r * 255),
        Math.round(color.g * 255),
        Math.round(color.b * 255),
        255
      ]);
      const texture = new THREE.DataTexture(data, 1, 1, THREE.RGBAFormat);
      texture.needsUpdate = true;
      return texture;
    }

    function getDefaultColor(index) {
      return BASE_COLOR_PALETTE[index % BASE_COLOR_PALETTE.length];
    }

    function getCenteredRect() {
      const rectWidth = width * 0.5;
      const rectHeight = height * 0.5;
      const left = (width - rectWidth) / 2;
      const bottom = (height - rectHeight) / 2;
      return {
        left,
        right: left + rectWidth,
        bottom,
        top: bottom + rectHeight
      };
    }

    function applyRectToGeometry(geometry, rect) {
      const posAttr = geometry.getAttribute('position');
      const arr = posAttr.array;
      arr[0] = rect.left;
      arr[1] = rect.top;
      arr[2] = 0;
      arr[3] = rect.right;
      arr[4] = rect.top;
      arr[5] = 0;
      arr[6] = rect.left;
      arr[7] = rect.bottom;
      arr[8] = 0;
      arr[9] = rect.right;
      arr[10] = rect.bottom;
      arr[11] = 0;
      posAttr.needsUpdate = true;
    }

    function applyPositionsToGeometry(geometry, positions) {
      const posAttr = geometry.getAttribute('position');
      const arr = posAttr.array;
      for (let i = 0; i < 12 && i < positions.length; i++) {
        arr[i] = positions[i];
      }
      posAttr.needsUpdate = true;
    }

    function positionsToQuad(arr) {
      return [
        { x: arr[0], y: arr[1] },
        { x: arr[3], y: arr[4] },
        { x: arr[6], y: arr[7] },
        { x: arr[9], y: arr[10] }
      ];
    }

    function swapArrayItems(arr, i, j) {
      const tmp = arr[i];
      arr[i] = arr[j];
      arr[j] = tmp;
    }

    function toScreenPoint(pt) {
      return { x: pt.x, y: height - pt.y };
    }

    function pointInQuad(screenQuad, px, py) {
      let inside = false;
      for (let i = 0, j = screenQuad.length - 1; i < screenQuad.length; j = i++) {
        const xi = screenQuad[i].x;
        const yi = screenQuad[i].y;
        const xj = screenQuad[j].x;
        const yj = screenQuad[j].y;
        const intersect = ((yi > py) !== (yj > py)) && (px < ((xj - xi) * (py - yi)) / (yj - yi + 1e-9) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    function pickSurfaceAtScreen(px, py) {
      for (let idx = surfaceOrder.length - 1; idx >= 0; idx--) {
        const id = surfaceOrder[idx];
        const surface = surfaces.get(id);
        if (!surface) continue;
        const posAttr = surface.geometry.getAttribute('position');
        const quad = positionsToQuad(posAttr.array);
        const screenQuad = quad.map(toScreenPoint);
        if (pointInQuad(screenQuad, px, py)) {
          return surface;
        }
      }
      return null;
    }

    function applyHomographyToPositions(solution, positions) {
      const h = solution;
      const out = new Float32Array(positions.length);
      for (let i = 0; i < positions.length; i += 3) {
        const x = positions[i];
        const y = positions[i + 1];
        const w = h[6] * x + h[7] * y + 1;
        const nx = (h[0] * x + h[1] * y + h[2]) / w;
        const ny = (h[3] * x + h[4] * y + h[5]) / w;
        out[i] = nx;
        out[i + 1] = ny;
        out[i + 2] = 0;
      }
      return out;
    }

    function createBaseGeometry(rect) {
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(12);
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      const uvs = new Float32Array([
        0, 1,
        1, 1,
        0, 0,
        1, 0
      ]);
      geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
      geometry.setAttribute('localUV', new THREE.BufferAttribute(uvs.slice(), 2));
      geometry.setIndex([0, 1, 2, 2, 1, 3]);
      applyRectToGeometry(geometry, rect || {
        left: 0,
        right: width,
        bottom: 0,
        top: height
      });
      return geometry;
    }

    function getSurfaceBounds(surface) {
      const posAttr = surface.geometry.getAttribute('position');
      const arr = posAttr.array;
      let minX = Infinity;
      let maxX = -Infinity;
      let minY = Infinity;
      let maxY = -Infinity;
      for (let i = 0; i < arr.length; i += 3) {
        const x = arr[i];
        const y = arr[i + 1];
        if (x < minX) minX = x;
        if (x > maxX) maxX = x;
        if (y < minY) minY = y;
        if (y > maxY) maxY = y;
      }
      const boundsWidth = Math.max(1, maxX - minX);
      const boundsHeight = Math.max(1, maxY - minY);
      return {
        width: boundsWidth,
        height: boundsHeight,
        aspect: boundsWidth / boundsHeight
      };
    }

    function serializeSurface(surface) {
      const posAttr = surface.geometry.getAttribute('position');
      const arr = Array.from(posAttr.array);
      const norm = arr.map((v, idx) => (idx % 3 === 0 ? v / width : idx % 3 === 1 ? v / height : v));
      return {
        id: surface.id,
        title: surface.title || '',
        positions: norm,
        colorHex: surface.colorHex,
        fitMode: surface.fitMode || 'cover',
        contentType: surface.contentType || 'color',
        gridEnabled: surface.material.uniforms.gridEnabled.value,
        gridLines: surface.material.uniforms.gridLines.value,
        gridLineWidth: surface.material.uniforms.gridLineWidth.value,
        gridColor: `#${surface.material.uniforms.gridColor.value.getHexString()}`,
        media: surface.currentMedia,
        effectName: surface.effectName || '',
        animationName: surface.animationName || '',
        imageUrl: surface.currentImageUrl || '',
        imageLabel: surface.imageLabel || '',
        videoUrl: surface.currentVideoUrl || '',
        videoLabel: surface.videoLabel || ''
      };
    }

    function saveState() {
      if (isRestoring) return;
      const state = {
        width,
        height,
        linkAllSurfaces,
        order: [...surfaceOrder],
        surfaces: [...surfaces.values()].map(serializeSurface)
      };
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      } catch (err) {
        console.error('State kon niet worden opgeslagen:', err);
      }
      if (!skipHistoryPush) {
        void pushHistorySnapshot(state);
      } else {
        skipHistoryPush = false;
      }
    }

    function restoreSurfaceGeometry(surface, normPositions) {
      const positions = normPositions.map((v, idx) => (idx % 3 === 0 ? v * width : idx % 3 === 1 ? v * height : v));
      applyPositionsToGeometry(surface.geometry, positions);
      setHandlesFromGeometry(surface);
      updateHomography(surface);
      surface.contentType = surface.contentType || 'color';
      updateContentVisibility(surface);
    }

    function loadState() {
      let raw;
      try {
        raw = localStorage.getItem(STORAGE_KEY);
      } catch (err) {
        console.error('State kon niet worden gelezen:', err);
        return;
      }
      if (!raw) return;
      let parsed;
      try {
        parsed = JSON.parse(raw);
      } catch (err) {
        console.error('State parsing mislukt:', err);
        return;
      }
      if (!parsed || !Array.isArray(parsed.order) || !Array.isArray(parsed.surfaces)) return;

      linkAllSurfaces = !!parsed.linkAllSurfaces;
      syncLinkAllToggle();

      // verwijder bestaande surfaces zonder opslaan
      const previousSaveFlag = isRestoring;
      isRestoring = true;
      [...surfaces.keys()].forEach(id => removeSurface(id, true));
      isRestoring = previousSaveFlag;

      surfaceOrder.length = 0;

      isRestoring = true;
      parsed.order.forEach(id => {
        const data = parsed.surfaces.find(s => s.id === id);
        const s = createSurface({
          colorHex: data && data.colorHex ? data.colorHex : DEFAULT_COLOR,
          fitMode: data && data.fitMode ? data.fitMode : 'cover'
        });
        if (!s) return;
        if (data) {
          applySavedSurfaceData(s, data);
        }
      });
      isRestoring = false;

      refreshSurfaceTitles();
      refreshSurfaceOrdering();
      refreshSurfaceList();
      skipHistoryPush = true;
      saveState();
    }

    function calculateTargetUVs(surface) {
      if (!surface.currentTexture || surface.currentMedia === 'color') {
        return [
          { u: 0, v: 1 },
          { u: 1, v: 1 },
          { u: 0, v: 0 },
          { u: 1, v: 0 }
        ];
      }
      const texture = surface.currentTexture;
      if (!texture.image) {
        return [
          { u: 0, v: 1 },
          { u: 1, v: 1 },
          { u: 0, v: 0 },
          { u: 1, v: 0 }
        ];
      }
      const texW = texture.image.videoWidth || texture.image.width || 1;
      const texH = texture.image.videoHeight || texture.image.height || 1;
      const textureAspectRaw = texW / texH;
      const textureAspect = Number.isFinite(textureAspectRaw) && textureAspectRaw > 0 ? textureAspectRaw : 1;
      const bounds = getSurfaceBounds(surface);
      const surfaceAspect = bounds.aspect;
      let uMin = 0, uMax = 1, vMin = 0, vMax = 1;
      const fitMode = surface.fitMode === 'contain' ? 'contain' : 'cover';
      if (fitMode === 'contain') {
        if (surfaceAspect > textureAspect) {
          const scaleU = surfaceAspect / textureAspect; // > 1, create side bars
          uMin = (1 - scaleU) / 2;
          uMax = uMin + scaleU;
        } else {
          const scaleV = textureAspect / surfaceAspect; // > 1, create top/bottom bars
          vMin = (1 - scaleV) / 2;
          vMax = vMin + scaleV;
        }
      } else { // cover
        if (surfaceAspect > textureAspect) {
          const scaleV = surfaceAspect / textureAspect;
          const visibleV = 1 / scaleV;
          vMin = (1 - visibleV) / 2;
          vMax = vMin + visibleV;
        } else {
          const scaleU = textureAspect / surfaceAspect;
          const visibleU = 1 / scaleU;
          uMin = (1 - visibleU) / 2;
          uMax = uMin + visibleU;
        }
      }
      return [
        { u: uMin, v: vMax },
        { u: uMax, v: vMax },
        { u: uMin, v: vMin },
        { u: uMax, v: vMin }
      ];
    }

    function solveHomography(src, dst) {
      const size = 8;
      const rows = size;
      const augmented = new Array(rows);

      for (let i = 0; i < 4; i++) {
        const { x, y } = src[i];
        const { u, v } = dst[i];
        augmented[i * 2] = [x, y, 1, 0, 0, 0, -u * x, -u * y, u];
        augmented[i * 2 + 1] = [0, 0, 0, x, y, 1, -v * x, -v * y, v];
      }

      for (let col = 0; col < size; col++) {
        let pivotRow = col;
        let maxVal = Math.abs(augmented[pivotRow][col]);
        for (let r = col + 1; r < rows; r++) {
          const val = Math.abs(augmented[r][col]);
          if (val > maxVal) {
            maxVal = val;
            pivotRow = r;
          }
        }

        if (maxVal < 1e-10) {
          return null;
        }

        if (pivotRow !== col) {
          const temp = augmented[col];
          augmented[col] = augmented[pivotRow];
          augmented[pivotRow] = temp;
        }

        const pivot = augmented[col][col];
        for (let c = col; c <= size; c++) {
          augmented[col][c] /= pivot;
        }

        for (let r = 0; r < rows; r++) {
          if (r === col) continue;
          const factor = augmented[r][col];
          if (Math.abs(factor) < 1e-12) continue;
          for (let c = col; c <= size; c++) {
            augmented[r][c] -= factor * augmented[col][c];
          }
        }
      }

      return augmented.map(row => row[size]);
    }

    function solveHomographyQuadToQuad(srcQuad, dstQuad) {
      const dst = dstQuad.map(pt => ({ u: pt.x, v: pt.y }));
      return solveHomography(srcQuad, dst);
    }

    function createHandleElement(surfaceId, index) {
      const handle = document.createElement('div');
      handle.className = 'handle';
      handle.dataset.surface = surfaceId;
      handle.dataset.index = index;
      app.appendChild(handle);
      return handle;
    }

    function createHandles(surfaceId) {
      return [0, 1, 2, 3].map(index => createHandleElement(surfaceId, index));
    }

    function setHandlesFromGeometry(surface) {
      const posAttr = surface.geometry.getAttribute('position');
      surface.handles.forEach((handle, index) => {
        const base = index * 3;
        const dom = worldToDom(posAttr.array[base], posAttr.array[base + 1]);
        handle.style.left = dom.left + 'px';
        handle.style.top = dom.top + 'px';
      });
    }

    function updateContentVisibility(surface) {
      if (!surface.ui || !surface.ui.rows) return;
      const type = surface.contentType || 'color';
      const { colorRow, videoRow, imageRow, effectRow, animationRow, fitRow } = surface.ui.rows;
      if (colorRow) colorRow.style.display = type === 'color' ? '' : 'none';
      if (videoRow) videoRow.style.display = type === 'video' ? '' : 'none';
      if (imageRow) imageRow.style.display = type === 'image' ? '' : 'none';
      if (effectRow) effectRow.style.display = type === 'effect' ? '' : 'none';
      if (animationRow) animationRow.style.display = type === 'animation' ? '' : 'none';
      if (fitRow) fitRow.style.display = (type === 'video' || type === 'image') ? '' : 'none';
    }

    function updateGridVisibility(surface) {
      if (!surface.ui) return;
      const enabled = surface.ui.gridEnabled ? surface.ui.gridEnabled.checked : true;
      if (surface.ui.gridConfig) {
        surface.ui.gridConfig.style.display = enabled ? 'flex' : 'none';
      }
    }

    function setSurfaceContentType(surface, type) {
      const newType = ['video', 'image', 'color', 'effect', 'animation'].includes(type) ? type : 'color';
      if (surface.contentType === newType) {
        updateContentVisibility(surface);
        return;
      }
      surface.contentType = newType;
      if (surface.ui && surface.ui.typeSelect) {
        surface.ui.typeSelect.value = newType;
      }

      if (newType === 'color') {
        if (surface.currentMedia === 'video') clearSurfaceVideo(surface);
        if (surface.currentMedia === 'image') clearSurfaceImage(surface);
        if (surface.currentMedia === 'effect') clearSurfaceEffect(surface, { revertToColor: false });
        if (surface.currentMedia === 'animation') clearSurfaceAnimation(surface, { revertToColor: false });
        setSurfaceTexture(surface, surface.colorTexture, 'color');
      } else if (newType === 'video') {
        if (surface.currentMedia === 'image') clearSurfaceImage(surface);
        if (surface.currentMedia === 'effect') clearSurfaceEffect(surface, { revertToColor: false });
        if (surface.currentMedia === 'animation') clearSurfaceAnimation(surface, { revertToColor: false });
        if (surface.currentMedia !== 'video') {
          setSurfaceTexture(surface, surface.colorTexture, 'color');
        }
      } else if (newType === 'image') {
        if (surface.currentMedia === 'video') clearSurfaceVideo(surface);
        if (surface.currentMedia === 'effect') clearSurfaceEffect(surface, { revertToColor: false });
        if (surface.currentMedia === 'animation') clearSurfaceAnimation(surface, { revertToColor: false });
        if (surface.currentMedia !== 'image') {
          setSurfaceTexture(surface, surface.colorTexture, 'color');
        }
      } else if (newType === 'effect') {
        if (surface.currentMedia === 'video') clearSurfaceVideo(surface);
        if (surface.currentMedia === 'image') clearSurfaceImage(surface);
        if (surface.currentMedia === 'animation') clearSurfaceAnimation(surface, { revertToColor: false });
        if (surface.currentMedia !== 'effect') {
          clearSurfaceEffect(surface, { revertToColor: false });
          setSurfaceTexture(surface, surface.colorTexture, 'color');
        }
      } else if (newType === 'animation') {
        if (surface.currentMedia === 'video') clearSurfaceVideo(surface);
        if (surface.currentMedia === 'image') clearSurfaceImage(surface);
        if (surface.currentMedia === 'effect') clearSurfaceEffect(surface, { revertToColor: false });
        if (surface.currentMedia !== 'animation') {
          clearSurfaceAnimation(surface, { revertToColor: false });
          setSurfaceTexture(surface, surface.colorTexture, 'color');
        }
        const desiredAnimation = (surface.ui && surface.ui.animationSelect && surface.ui.animationSelect.value)
          || surface.animationName
          || 'conic-grid-shift';
        if (desiredAnimation) {
          applyAnimationToSurface(surface, desiredAnimation, { force: true });
        }
      }

      updateContentVisibility(surface);
      updateSurfaceStatus(surface);
      saveState();
    }

    function updateHomography(surface) {
      const posAttr = surface.geometry.getAttribute('position');
      const quad = [];
      for (let i = 0; i < 4; i++) {
        const base = i * 3;
        quad.push({ x: posAttr.array[base], y: posAttr.array[base + 1] });
      }
      const targetUVs = calculateTargetUVs(surface);
      const solution = solveHomography(quad, targetUVs);
      const baseUVs = [
        { u: 0, v: 1 },
        { u: 1, v: 1 },
        { u: 0, v: 0 },
        { u: 1, v: 0 }
      ];
      const gridSolution = solveHomography(quad, baseUVs);
      if (!solution || !gridSolution) return;
      surface.homography.set(
        solution[0], solution[1], solution[2],
        solution[3], solution[4], solution[5],
        solution[6], solution[7], 1
      );
      surface.material.uniforms.gridHomography.value.set(
        gridSolution[0], gridSolution[1], gridSolution[2],
        gridSolution[3], gridSolution[4], gridSolution[5],
        gridSolution[6], gridSolution[7], 1
      );
      const bounds = getSurfaceBounds(surface);
      surface.material.uniforms.surfaceWidth.value = bounds.width;
      surface.material.uniforms.surfaceHeight.value = bounds.height;
      surface.material.uniformsNeedUpdate = true;
    }

    function setSurfaceTexture(surface, texture, mode = 'color') {
      surface.material.uniforms.map.value = texture;
      surface.currentTexture = texture;
      surface.currentMedia = mode;
      surface.material.needsUpdate = true;
      surface.material.uniformsNeedUpdate = true;
      updateHomography(surface);
    }

    function updateSurfaceStatus(surface) {
      if (!surface.ui) return;
      if (surface.ui.removeVideoBtn) {
        surface.ui.removeVideoBtn.disabled = surface.currentMedia !== 'video';
      }
      if (surface.ui.removeImageBtn) {
        surface.ui.removeImageBtn.disabled = surface.currentMedia !== 'image';
      }
    }

    function clearSurfaceVideo(surface) {
      if (surface.currentMedia !== 'video' && !surface.currentVideoUrl) return;
      if (surface.currentVideoUrl) {
        URL.revokeObjectURL(surface.currentVideoUrl);
        surface.currentVideoUrl = null;
      }
      surface.videoElement.pause();
      surface.videoElement.removeAttribute('src');
      surface.videoElement.load();
      surface.videoLabel = '';
      setSurfaceTexture(surface, surface.colorTexture, 'color');
      if (surface.ui && surface.ui.videoInput) {
        surface.ui.videoInput.value = '';
      }
      if (surface.ui && surface.ui.removeVideoBtn) {
        surface.ui.removeVideoBtn.disabled = true;
      }
      updateSurfaceStatus(surface);
      applyPlaceholderImage(surface);
    }

    function clearSurfaceImage(surface) {
      if (!surface.imageTexture && surface.currentMedia !== 'image') return;
      if (surface.imageTexture) {
        if (!surface.usingPlaceholderImage) {
          surface.imageTexture.dispose();
        }
        surface.imageTexture = null;
      }
      if (surface.currentImageUrl) {
        URL.revokeObjectURL(surface.currentImageUrl);
        surface.currentImageUrl = null;
      }
      surface.imageLabel = '';
      surface.usingPlaceholderImage = false;
      if (surface.ui && surface.ui.imageInput) {
        surface.ui.imageInput.value = '';
      }
      if (surface.ui && surface.ui.removeImageBtn) {
        surface.ui.removeImageBtn.disabled = true;
      }
      setSurfaceTexture(surface, surface.colorTexture, 'color');
      updateSurfaceStatus(surface);
      applyPlaceholderImage(surface);
    }

    function handleSurfaceVideoSelection(surface, file) {
      if (!file) return;
      if (surface.currentMedia === 'effect') {
        clearSurfaceEffect(surface, { revertToColor: false });
      }
      if (surface.currentMedia === 'image') {
        clearSurfaceImage(surface);
      }
      if (surface.currentVideoUrl) {
        URL.revokeObjectURL(surface.currentVideoUrl);
      }
      surface.currentVideoUrl = URL.createObjectURL(file);
      surface.videoElement.pause();
      surface.videoElement.src = surface.currentVideoUrl;
      surface.videoElement.load();
      surface.videoElement.addEventListener('loadeddata', () => {
        surface.videoTexture.format = THREE.RGBAFormat;
        surface.videoTexture.premultiplyAlpha = false;
        surface.videoTexture.needsUpdate = true;
        updateHomography(surface);
      }, { once: true });
      surface.videoElement.play().catch(err => console.error('Kon video niet starten:', err));
      surface.videoLabel = file.name;
      setSurfaceTexture(surface, surface.videoTexture, 'video');
      if (surface.ui && surface.ui.removeVideoBtn) {
        surface.ui.removeVideoBtn.disabled = false;
      }
      updateSurfaceStatus(surface);
      skipHistoryPush = true;
      saveState();
    }

    function handleSurfaceImageSelection(surface, file) {
      if (!file) return;
      if (surface.currentMedia === 'effect') {
        clearSurfaceEffect(surface, { revertToColor: false });
      }
      if (surface.currentMedia === 'video') {
        clearSurfaceVideo(surface);
      }
      clearSurfaceImage(surface);
      const objectUrl = URL.createObjectURL(file);
      textureLoader.load(
        objectUrl,
        texture => {
          if (surface.imageTexture) {
            surface.imageTexture.dispose();
          }
          texture.minFilter = THREE.LinearFilter;
          texture.magFilter = THREE.LinearFilter;
          surface.imageTexture = texture;
          surface.imageLabel = file.name;
          surface.currentImageUrl = objectUrl;
          surface.usingPlaceholderImage = false;
          setSurfaceTexture(surface, texture, 'image');
          if (surface.ui && surface.ui.removeImageBtn) {
            surface.ui.removeImageBtn.disabled = false;
          }
          updateSurfaceStatus(surface);
          skipHistoryPush = true;
          saveState();
        },
        undefined,
        error => {
          console.error('Kon afbeelding niet laden:', error);
          URL.revokeObjectURL(objectUrl);
          if (surface.ui && surface.ui.imageInput) {
            surface.ui.imageInput.value = '';
          }
        }
      );
    }

    function clearSurfaceEffect(surface, { resetUI = true, revertToColor = true } = {}) {
      if (!surface.effectName && !surface.effectTexture) return;
      if (surface.effectTexture) {
        surface.effectTexture.dispose();
      }
      surface.effectTexture = null;
      surface.effectCanvas = null;
      surface.effectCtx = null;
      surface.effectDefinition = null;
      surface.effectName = '';
      surface.effectStartTime = 0;
      surface.effectLastTime = 0;
      surface.effectAspect = 1;
      surface.effectBounds = null;
      if (resetUI && surface.ui && surface.ui.effectSelect) {
        surface.ui.effectSelect.value = '';
      }
      if (revertToColor) {
        setSurfaceTexture(surface, surface.colorTexture, 'color');
        updateSurfaceStatus(surface);
        applyPlaceholderImage(surface);
      }
    }

    function applyEffectToSurface(surface, effectName, { force = false } = {}) {
      const isActiveEffect = surface.currentMedia === 'effect' && surface.effectName === effectName;
      if (!force && isActiveEffect) return;
      if (!effectName) {
        clearSurfaceEffect(surface, { resetUI: false, revertToColor: true });
        if (surface.ui && surface.ui.effectSelect) {
          surface.ui.effectSelect.value = '';
        }
        return;
      }
      if (surface.currentMedia === 'video') {
        clearSurfaceVideo(surface);
      } else if (surface.currentMedia === 'image' && !surface.usingPlaceholderImage) {
        clearSurfaceImage(surface);
      }
      clearSurfaceEffect(surface, { resetUI: false, revertToColor: false });
      const definition = EFFECT_DEFINITIONS[effectName];
      if (!definition) return;
      const bounds = getSurfaceBounds(surface);
      const baseSize = definition.size || 512;
      const aspect = Math.max(bounds.aspect, 1 / 64);
      let canvasWidth = baseSize;
      let canvasHeight = baseSize;
      if (aspect > 1) {
        canvasWidth = Math.round(baseSize * aspect);
      } else {
        canvasHeight = Math.round(baseSize / aspect);
      }
      const maxSize = definition.maxSize || 2048;
      const scale = Math.min(maxSize / Math.max(canvasWidth, canvasHeight), 1);
      canvasWidth = Math.max(4, Math.round(canvasWidth * scale));
      canvasHeight = Math.max(4, Math.round(canvasHeight * scale));
      const canvas = document.createElement('canvas');
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      const ctx = canvas.getContext('2d');
      if (!ctx) {
        console.error('Kan canvas context niet creren voor effect');
        return;
      }
      const texture = new THREE.CanvasTexture(canvas);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      surface.effectName = effectName;
      surface.effectCanvas = canvas;
      surface.effectCtx = ctx;
      surface.effectDefinition = definition;
      surface.effectTexture = texture;
      surface.effectStartTime = performance.now();
      surface.effectLastTime = 0;
      surface.effectAspect = aspect;
      surface.effectBounds = bounds;
      surface.usingPlaceholderImage = false;
      surface.imageTexture = null;
      surface.currentImageUrl = null;
      surface.imageLabel = '';
      setSurfaceTexture(surface, texture, 'effect');
      if (surface.ui && surface.ui.effectSelect) {
        surface.ui.effectSelect.value = effectName;
      }
      updateSurfaceStatus(surface);
      saveState();
    }

    function clearSurfaceAnimation(surface, { resetUI = true, revertToColor = true } = {}) {
      if (!surface.animationName && !surface.animationTexture) return;
      if (surface.animationTexture) {
        surface.animationTexture.dispose();
      }
      surface.animationTexture = null;
      surface.animationCanvas = null;
      surface.animationCtx = null;
      surface.animationDefinition = null;
      surface.animationName = '';
      surface.animationStartTime = 0;
      surface.animationLastTime = 0;
      surface.animationAspect = 1;
      surface.animationBounds = null;
      if (resetUI && surface.ui && surface.ui.animationSelect) {
        surface.ui.animationSelect.value = '';
      }
      if (revertToColor) {
        setSurfaceTexture(surface, surface.colorTexture, 'color');
        updateSurfaceStatus(surface);
        applyPlaceholderImage(surface);
      }
    }

    function applyAnimationToSurface(surface, animationName, { force = false } = {}) {
      const isActive = surface.currentMedia === 'animation' && surface.animationName === animationName;
      if (!force && isActive) return;
      if (!animationName) {
        clearSurfaceAnimation(surface, { resetUI: false, revertToColor: true });
        if (surface.ui && surface.ui.animationSelect) {
          surface.ui.animationSelect.value = '';
        }
        return;
      }
      if (surface.currentMedia === 'video') {
        clearSurfaceVideo(surface);
      } else if (surface.currentMedia === 'image' && !surface.usingPlaceholderImage) {
        clearSurfaceImage(surface);
      }
      if (surface.currentMedia === 'effect') {
        clearSurfaceEffect(surface, { revertToColor: false });
      }
      clearSurfaceAnimation(surface, { resetUI: false, revertToColor: false });
      const definition = ANIMATION_DEFINITIONS[animationName];
      if (!definition) return;
      const bounds = getSurfaceBounds(surface);
      const baseSize = definition.size || 1024;
      const aspect = Math.max(bounds.aspect, 1 / 64);
      let canvasWidth = baseSize;
      let canvasHeight = baseSize;
      if (aspect > 1) {
        canvasWidth = Math.round(baseSize * aspect);
      } else {
        canvasHeight = Math.round(baseSize / aspect);
      }
      const maxSize = definition.maxSize || 2048;
      const scale = Math.min(maxSize / Math.max(canvasWidth, canvasHeight), 1);
      canvasWidth = Math.max(4, Math.round(canvasWidth * scale));
      canvasHeight = Math.max(4, Math.round(canvasHeight * scale));
      const canvas = document.createElement('canvas');
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      const ctx = canvas.getContext('2d');
      if (!ctx) {
        console.error('Kan canvas context niet creren voor animatie');
        return;
      }
      const texture = new THREE.CanvasTexture(canvas);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      surface.animationName = animationName;
      surface.animationCanvas = canvas;
      surface.animationCtx = ctx;
      surface.animationDefinition = definition;
      surface.animationTexture = texture;
      surface.animationStartTime = performance.now();
      surface.animationLastTime = 0;
      surface.animationAspect = aspect;
      surface.animationBounds = bounds;
      surface.usingPlaceholderImage = false;
      surface.imageTexture = null;
      surface.currentImageUrl = null;
      surface.imageLabel = '';
      setSurfaceTexture(surface, texture, 'animation');
      if (surface.ui && surface.ui.animationSelect) {
        surface.ui.animationSelect.value = animationName;
      }
      updateSurfaceStatus(surface);
      saveState();
    }

    function applyPlaceholderImage(surface) {
      if (placeholderLoadFailed || isRestoring) return;
      onPlaceholderReady(texture => {
        if (!surfaces.has(surface.id)) return;
        if (surface.currentMedia !== 'color') return;
        surface.imageTexture = texture;
        surface.imageLabel = PLACEHOLDER_IMAGE;
        surface.currentImageUrl = null;
        surface.usingPlaceholderImage = true;
        setSurfaceTexture(surface, texture, 'image');
        if (surface.ui && surface.ui.removeImageBtn) {
          surface.ui.removeImageBtn.disabled = false;
        }
        updateSurfaceStatus(surface);
      });
    }

    function applySurfaceColor(surface, rawValue) {
      const normalized = normalizeHex(rawValue || '');
      if (!normalized) {
        if (surface.ui && surface.ui.colorInput) {
          surface.ui.colorInput.classList.add('invalid');
        }
        return;
      }
      if (surface.ui && surface.ui.colorInput) {
        surface.ui.colorInput.classList.remove('invalid');
        surface.ui.colorInput.value = normalized;
      }
      const previousTexture = surface.colorTexture;
      surface.colorHex = normalized;
      surface.colorTexture = createColorTexture(normalized);
      if (surface.currentMedia === 'video') {
        clearSurfaceVideo(surface);
      } else if (surface.currentMedia === 'image') {
        clearSurfaceImage(surface);
      } else if (surface.currentMedia === 'effect') {
        clearSurfaceEffect(surface, { revertToColor: false });
      } else if (surface.currentMedia === 'animation') {
        clearSurfaceAnimation(surface, { revertToColor: false });
      }
      setSurfaceTexture(surface, surface.colorTexture, 'color');
      if (previousTexture) {
        previousTexture.dispose();
      }
      updateSurfaceStatus(surface);
      saveState();
    }

    function createSurfaceUI(surface) {
      const block = document.createElement('div');
      block.className = 'control-block';
      block.dataset.surfaceId = surface.id;

      const header = document.createElement('div');
      header.className = 'control-block-header';

      const title = document.createElement('div');
      title.className = 'control-title';
      title.contentEditable = 'true';
      const initialTitle = surface.title && surface.title.trim() ? surface.title.trim() : `Content ${surfaceOrder.indexOf(surface.id) + 1}`;
      surface.title = initialTitle;
      title.textContent = initialTitle;
      title.addEventListener('keydown', event => {
        if (event.key === 'Enter') {
          event.preventDefault();
          title.blur();
        }
      });
      title.addEventListener('blur', () => {
        const value = (title.textContent || '').trim();
        surface.title = value || `Content ${surfaceOrder.indexOf(surface.id) + 1}`;
        refreshSurfaceTitles();
        saveState();
      });
      header.appendChild(title);

      const headerBtns = document.createElement('div');
      headerBtns.style.display = 'flex';
      headerBtns.style.gap = '6px';
      headerBtns.style.alignItems = 'center';

      const upBtn = document.createElement('button');
      upBtn.type = 'button';
      upBtn.className = 'secondary bg-transparent p-1';
      const upIcon = document.createElement('span');
      upIcon.className = 'material-symbols-outlined text-light';
      upIcon.textContent = 'arrow_upward';
      upBtn.appendChild(upIcon);
      headerBtns.appendChild(upBtn);

      const downBtn = document.createElement('button');
      downBtn.type = 'button';
      downBtn.className = 'secondary bg-transparent p-1';
      const downIcon = document.createElement('span');
      downIcon.className = 'material-symbols-outlined text-light';
      downIcon.textContent = 'arrow_downward';
      downBtn.appendChild(downIcon);
      headerBtns.appendChild(downBtn);

      const duplicateBtn = document.createElement('button');
      duplicateBtn.type = 'button';
      duplicateBtn.className = 'secondary bg-transparent p-1';
      /* duplicateBtn.textContent = 'Dupliceer'; */
      const duplicateIcon = document.createElement('span');
      duplicateIcon.className = 'material-symbols-outlined text-light';
      duplicateIcon.textContent = 'content_copy';
      duplicateBtn.appendChild(duplicateIcon)
      headerBtns.appendChild(duplicateBtn);

      const removeBtn = document.createElement('button');
      removeBtn.type = 'button';
      removeBtn.className = 'control-remove-btn bg-transparent p-1 ';
      removeBtn.setAttribute('aria-label', 'Verwijder content');
      const removeIcon = document.createElement('span');
      removeIcon.className = 'material-symbols-outlined text-light';
      removeIcon.textContent = 'close';
      removeBtn.appendChild(removeIcon)
      headerBtns.appendChild(removeBtn);

      header.appendChild(headerBtns);
      block.appendChild(header);

      const typeRow = document.createElement('div');
      typeRow.className = 'control-row';
      const typeLabel = document.createElement('span');
      typeLabel.className = 'control-label';
      typeLabel.textContent = 'Content type';
      const typeSelect = document.createElement('select');
      const typeOptions = [
        { value: 'video', label: 'Video' },
        { value: 'image', label: 'Afbeelding' },
        { value: 'color', label: 'Kleur' },
        { value: 'effect', label: 'Effect' },
        { value: 'animation', label: 'Animatie' }
      ];
      typeOptions.forEach(opt => {
        const option = document.createElement('option');
        option.value = opt.value;
        option.textContent = opt.label;
        typeSelect.appendChild(option);
      });
      typeRow.appendChild(typeLabel);
      typeRow.appendChild(typeSelect);
      block.appendChild(typeRow);

      const colorRow = document.createElement('div');
      colorRow.className = 'control-row';
      const colorLabel = document.createElement('span');
      colorLabel.className = 'control-label';
      colorLabel.textContent = 'Kleur';
      const colorInput = document.createElement('input');
      colorInput.type = 'color';
      colorInput.value = surface.colorHex !== 'transparent' ? surface.colorHex : '#ffffff';
      const applyBtn = document.createElement('button');
      applyBtn.type = 'button';
      applyBtn.className = 'secondary';
      applyBtn.textContent = 'Transparant';
      colorRow.appendChild(colorLabel);
      colorRow.appendChild(colorInput);
      colorRow.appendChild(applyBtn);
      block.appendChild(colorRow);

      const videoRow = document.createElement('div');
      videoRow.className = 'control-row';
      const videoLabel = document.createElement('span');
      videoLabel.className = 'control-label';
      videoLabel.textContent = 'Video';
      const videoInput = document.createElement('input');
      videoInput.type = 'file';
      videoInput.accept = 'video/*';
      const removeVideoBtn = document.createElement('button');
      removeVideoBtn.type = 'button';
      removeVideoBtn.className = 'secondary';
      removeVideoBtn.textContent = 'Verwijder video';
      removeVideoBtn.disabled = true;
      videoRow.appendChild(videoLabel);
      videoRow.appendChild(videoInput);
      videoRow.appendChild(removeVideoBtn);
      block.appendChild(videoRow);

      const imageRow = document.createElement('div');
      imageRow.className = 'control-row';
      const imageLabel = document.createElement('span');
      imageLabel.className = 'control-label';
      imageLabel.textContent = 'Afbeelding';
      const imageInput = document.createElement('input');
      imageInput.type = 'file';
      imageInput.accept = 'image/*';
      const removeImageBtn = document.createElement('button');
      removeImageBtn.type = 'button';
      removeImageBtn.className = 'secondary';
      removeImageBtn.textContent = 'Verwijder afbeelding';
      removeImageBtn.disabled = true;
      imageRow.appendChild(imageLabel);
      imageRow.appendChild(imageInput);
      imageRow.appendChild(removeImageBtn);
      block.appendChild(imageRow);

      const effectRow = document.createElement('div');
      effectRow.className = 'control-row';
      const effectLabel = document.createElement('span');
      effectLabel.className = 'control-label';
      effectLabel.textContent = 'CSS effect';
      const effectSelect = document.createElement('select');
      EFFECT_OPTIONS.forEach(optionData => {
        const option = document.createElement('option');
        option.value = optionData.value;
        option.textContent = optionData.label;
        effectSelect.appendChild(option);
      });
      effectRow.appendChild(effectLabel);
      effectRow.appendChild(effectSelect);
      block.appendChild(effectRow);

      const animationRow = document.createElement('div');
      animationRow.className = 'control-row';
      const animationLabel = document.createElement('span');
      animationLabel.className = 'control-label';
      animationLabel.textContent = 'Animatie patroon';
      const animationSelect = document.createElement('select');
      ANIMATION_OPTIONS.forEach(optionData => {
        const option = document.createElement('option');
        option.value = optionData.value;
        option.textContent = optionData.label;
        animationSelect.appendChild(option);
      });
      animationRow.appendChild(animationLabel);
      animationRow.appendChild(animationSelect);
      block.appendChild(animationRow);

      const fitRow = document.createElement('div');
      fitRow.className = 'control-row';
      const fitLabel = document.createElement('span');
      fitLabel.className = 'control-label';
      fitLabel.textContent = 'Schaal';
      const fitSelect = document.createElement('select');
      const fitOptions = [
        { value: 'cover', label: 'Cover (vullend)' },
        { value: 'contain', label: 'Contain (passen)' }
      ];
      fitOptions.forEach(opt => {
        const option = document.createElement('option');
        option.value = opt.value;
        option.textContent = opt.label;
        fitSelect.appendChild(option);
      });
      fitRow.appendChild(fitLabel);
      fitRow.appendChild(fitSelect);
      block.appendChild(fitRow);

      const gridRow = document.createElement('div');
      gridRow.className = 'control-row';
      const gridLabel = document.createElement('span');
      gridLabel.className = 'control-label';
      gridLabel.textContent = 'Grid';
      const gridEnabled = document.createElement('input');
      gridEnabled.type = 'checkbox';
      gridEnabled.checked = true;
      const gridConfig = document.createElement('div');
      gridConfig.style.display = 'flex';
      gridConfig.style.flexWrap = 'wrap';
      gridConfig.style.gap = '6px';
      const gridLinesLabel = document.createElement('span');
      gridLinesLabel.className = 'control-label';
      gridLinesLabel.textContent = 'Lijnen';
      const gridLines = document.createElement('input');
      gridLines.type = 'number';
      gridLines.value = 10;
      gridLines.min = 1;
      gridLines.max = 200;
      const gridWidthLabel = document.createElement('span');
      gridWidthLabel.className = 'control-label';
      gridWidthLabel.textContent = 'Dikte';
      const gridWidth = document.createElement('input');
      gridWidth.type = 'number';
      gridWidth.value = 3;
      gridWidth.min = 0.5;
      gridWidth.max = 50;
      gridWidth.step = 0.5;
      const gridColorLabel = document.createElement('span');
      gridColorLabel.className = 'control-label';
      gridColorLabel.textContent = 'Kleur';
      const gridColor = document.createElement('input');
      gridColor.type = 'color';
      gridColor.value = '#ffffff';
      gridConfig.appendChild(gridLinesLabel);
      gridConfig.appendChild(gridLines);
      gridConfig.appendChild(gridWidthLabel);
      gridConfig.appendChild(gridWidth);
      gridConfig.appendChild(gridColorLabel);
      gridConfig.appendChild(gridColor);
      gridRow.appendChild(gridLabel);
      gridRow.appendChild(gridEnabled);
      gridRow.appendChild(gridConfig);
      block.appendChild(gridRow);

      contentList.appendChild(block);

      surface.ui = {
        block,
        title,
        upBtn,
        downBtn,
        duplicateBtn,
        typeSelect,
        fitSelect,
        colorInput,
        applyBtn,
        videoInput,
        removeVideoBtn,
        imageInput,
        removeImageBtn,
        effectSelect,
        animationSelect,
        removeBtn,
        gridEnabled,
        gridLines,
        gridWidth,
        gridColor,
        gridConfig,
        rows: {
          colorRow,
          videoRow,
          imageRow,
          effectRow,
          animationRow,
          fitRow,
          gridRow
        }
      };
      if (surface.effectName) {
        effectSelect.value = surface.effectName;
      }
      if (surface.animationName) {
        animationSelect.value = surface.animationName;
      }
      if (fitSelect) {
        fitSelect.value = surface.fitMode || 'cover';
      }
      if (typeSelect) {
        typeSelect.value = surface.contentType || 'color';
      }

      // ensure newly created block is in correct DOM order
      refreshSurfaceList();

      applyBtn.addEventListener('click', () => applySurfaceColor(surface, 'transparent'));
      colorInput.addEventListener('input', () => applySurfaceColor(surface, colorInput.value));
      colorInput.addEventListener('keydown', event => {
        if (event.key === 'Enter') {
          event.preventDefault();
          applySurfaceColor(surface, colorInput.value);
        }
      });
      colorInput.addEventListener('blur', () => applySurfaceColor(surface, colorInput.value));
      videoInput.addEventListener('change', event => {
        const file = event.target.files && event.target.files[0];
        handleSurfaceVideoSelection(surface, file);
      });
      removeVideoBtn.addEventListener('click', () => clearSurfaceVideo(surface));
      imageInput.addEventListener('change', event => {
        const file = event.target.files && event.target.files[0];
        handleSurfaceImageSelection(surface, file);
      });
      removeImageBtn.addEventListener('click', () => clearSurfaceImage(surface));
      effectSelect.addEventListener('change', event => {
        applyEffectToSurface(surface, event.target.value);
      });
      animationSelect.addEventListener('change', event => {
        setSurfaceContentType(surface, 'animation');
        applyAnimationToSurface(surface, event.target.value, { force: true });
      });
      typeSelect.addEventListener('change', event => {
        setSurfaceContentType(surface, event.target.value);
      });
      fitSelect.addEventListener('change', event => {
        surface.fitMode = event.target.value === 'contain' ? 'contain' : 'cover';
        updateHomography(surface);
        saveState();
      });
      upBtn.addEventListener('click', () => moveSurface(surface.id, -1));
      downBtn.addEventListener('click', () => moveSurface(surface.id, 1));
      duplicateBtn.addEventListener('click', () => duplicateSurface(surface.id));
      removeBtn.addEventListener('click', () => removeSurface(surface.id));

      // init grid defaults
      surface.material.uniforms.gridEnabled.value = true;
      surface.material.uniformsNeedUpdate = true;

      gridEnabled.addEventListener('change', () => {
        surface.material.uniforms.gridEnabled.value = gridEnabled.checked;
        surface.material.uniformsNeedUpdate = true;
        updateGridVisibility(surface);
        saveState();
      });
      gridLines.addEventListener('input', () => {
        const value = parseFloat(gridLines.value) || 10;
        surface.material.uniforms.gridLines.value = Math.max(1, value);
        surface.material.uniformsNeedUpdate = true;
        saveState();
      });
      gridWidth.addEventListener('input', () => {
        const value = parseFloat(gridWidth.value) || 3;
        surface.material.uniforms.gridLineWidth.value = Math.max(0, value);
        surface.material.uniformsNeedUpdate = true;
        saveState();
      });
      gridColor.addEventListener('input', () => {
        const color = new THREE.Color(gridColor.value);
        surface.material.uniforms.gridColor.value = color;
        surface.material.uniformsNeedUpdate = true;
        saveState();
      });
      gridColor.addEventListener('blur', () => {
        const color = new THREE.Color(gridColor.value);
        surface.material.uniforms.gridColor.value = color;
        surface.material.uniformsNeedUpdate = true;
        saveState();
      });

      // initial UI values sync
      gridEnabled.checked = surface.material.uniforms.gridEnabled.value;
      gridLines.value = surface.material.uniforms.gridLines.value;
      gridWidth.value = surface.material.uniforms.gridLineWidth.value;
      updateGridVisibility(surface);
    }

    function refreshSurfaceTitles() {
      surfaceOrder.forEach((id, index) => {
        const surface = surfaces.get(id);
        if (surface && surface.ui && surface.ui.title) {
          const fallback = `Content ${index + 1}`;
          const displayTitle = surface.title && surface.title.trim() ? surface.title.trim() : fallback;
          surface.ui.title.textContent = displayTitle;
        }
      });
    }

    function refreshSurfaceOrdering() {
      surfaceOrder.forEach((id, index) => {
        const surface = surfaces.get(id);
        if (surface) {
          surface.mesh.renderOrder = index;
        }
      });
    }

    function refreshSurfaceList() {
      if (!contentList) return;
      surfaceOrder.forEach(id => {
        const surface = surfaces.get(id);
        if (surface && surface.ui && surface.ui.block && surface.ui.block.parentElement !== contentList) {
          // ensure block is attached before reordering
          contentList.appendChild(surface.ui.block);
        } else if (surface && surface.ui && surface.ui.block) {
          contentList.appendChild(surface.ui.block);
        }
      });
    }

    function moveSurface(surfaceId, direction) {
      const idx = surfaceOrder.indexOf(surfaceId);
      if (idx === -1) return;
      const newIdx = idx + direction;
      if (newIdx < 0 || newIdx >= surfaceOrder.length) return;
      swapArrayItems(surfaceOrder, idx, newIdx);
      refreshSurfaceTitles();
      refreshSurfaceOrdering();
      refreshSurfaceList();
      saveState();
    }

    function applySavedSurfaceData(surface, data) {
      if (!data) return;
      surface.contentType = data.contentType || data.media || 'color';
      surface.title = data.title || surface.title || '';
      surface.fitMode = data.fitMode === 'contain' ? 'contain' : 'cover';
      surface.animationName = data.animationName || surface.animationName || '';
      restoreSurfaceGeometry(surface, data.positions || []);
      surface.material.uniforms.gridEnabled.value = !!data.gridEnabled;
      surface.material.uniforms.gridLines.value = Math.max(1, data.gridLines || 10);
      surface.material.uniforms.gridLineWidth.value = Math.max(0, data.gridLineWidth || 1);
      if (data.gridColor) {
        surface.material.uniforms.gridColor.value = new THREE.Color(data.gridColor);
      }

      if (data.media === 'animation' && data.animationName) {
        applyAnimationToSurface(surface, data.animationName, { force: true });
      } else if (data.media === 'effect' && data.effectName) {
        applyEffectToSurface(surface, data.effectName, { force: true });
      } else if (data.media === 'image' && data.imageUrl) {
        surface.currentImageUrl = data.imageUrl;
        surface.imageLabel = data.imageLabel || '';
        textureLoader.load(
          data.imageUrl,
          texture => {
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            surface.imageTexture = texture;
            setSurfaceTexture(surface, texture, 'image');
            updateSurfaceStatus(surface);
            if (surface.ui) {
              surface.ui.imageInput.value = '';
            }
          },
          undefined,
          () => {}
        );
      } else if (data.media === 'video' && data.videoUrl) {
        surface.currentVideoUrl = data.videoUrl;
        surface.videoLabel = data.videoLabel || '';
        surface.videoElement.pause();
        surface.videoElement.src = data.videoUrl;
        surface.videoElement.load();
        surface.videoElement.addEventListener('loadeddata', () => {
          surface.videoTexture.format = THREE.RGBAFormat;
          surface.videoTexture.premultiplyAlpha = false;
          surface.videoTexture.needsUpdate = true;
          setSurfaceTexture(surface, surface.videoTexture, 'video');
          updateSurfaceStatus(surface);
        }, { once: true });
        surface.videoElement.play().catch(() => {});
      } else {
        setSurfaceTexture(surface, surface.colorTexture, 'color');
      }

      surface.material.uniformsNeedUpdate = true;
      if (surface.ui) {
        if (surface.ui.typeSelect) surface.ui.typeSelect.value = surface.contentType;
        if (surface.ui.title) surface.ui.title.textContent = surface.title && surface.title.trim() ? surface.title : surface.ui.title.textContent;
        surface.ui.fitSelect.value = surface.fitMode;
        surface.ui.gridEnabled.checked = !!data.gridEnabled;
        surface.ui.gridLines.value = data.gridLines || 10;
        surface.ui.gridWidth.value = data.gridLineWidth || 1;
        surface.ui.gridColor.value = data.gridColor || '#ffffff';
        surface.ui.colorInput.value = (data.colorHex && data.colorHex !== 'transparent') ? data.colorHex : (surface.colorHex !== 'transparent' ? surface.colorHex : '#ffffff');
        if (surface.ui.effectSelect) surface.ui.effectSelect.value = data.effectName || '';
        if (surface.ui.animationSelect) surface.ui.animationSelect.value = data.animationName || '';
      }
      updateContentVisibility(surface);
      updateGridVisibility(surface);
    }

    function createSurface({ colorHex, fitMode } = {}) {
      const id = `surface-${++surfaceCounter}`;
      const videoElement = createVideoElement();
      const videoTexture = createVideoTexture(videoElement);
      const paletteColor = colorHex || DEFAULT_COLOR;
      const normalizedColor = normalizeHex(paletteColor) || DEFAULT_COLOR;
      const colorTexture = createColorTexture(normalizedColor);
      const geometry = createBaseGeometry(getCenteredRect());
      const homographyMatrix = new THREE.Matrix3();
      const material = createShaderMaterial(colorTexture, homographyMatrix);
      const mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);
      const handles = createHandles(id);

      const surface = {
        id,
        geometry,
        homography: homographyMatrix,
        material,
        mesh,
        handles,
        videoElement,
        videoTexture,
        colorTexture,
        colorHex: normalizedColor,
        currentVideoUrl: null,
        currentMedia: 'color',
        videoLabel: '',
        imageTexture: null,
        currentImageUrl: null,
        imageLabel: '',
        usingPlaceholderImage: false,
        effectName: '',
        effectCanvas: null,
        effectCtx: null,
        effectTexture: null,
        effectDefinition: null,
        effectStartTime: 0,
        effectLastTime: 0,
        effectAspect: 1,
        effectBounds: null,
        animationName: '',
        animationCanvas: null,
        animationCtx: null,
        animationTexture: null,
        animationDefinition: null,
        animationStartTime: 0,
        animationLastTime: 0,
        animationAspect: 1,
        animationBounds: null,
        fitMode: fitMode === 'contain' ? 'contain' : 'cover',
        contentType: 'color',
        title: '',
        ui: null
      };

      surfaces.set(id, surface);
      surfaceOrder.push(id);

      setSurfaceTexture(surface, colorTexture, 'color');
      setHandlesFromGeometry(surface);
      updateHomography(surface);
      createSurfaceUI(surface);
      updateSurfaceStatus(surface);
      applyPlaceholderImage(surface);
      updateContentVisibility(surface);
      updateGridVisibility(surface);
      refreshSurfaceTitles();
      refreshSurfaceOrdering();
      refreshSurfaceList();
      saveState();
      return surface;
    }

    function duplicateSurface(surfaceId) {
      const source = surfaces.get(surfaceId);
      if (!source) return;
      const data = serializeSurface(source);
      const previousSaveFlag = isRestoring;
      isRestoring = true;
      const clone = createSurface({ colorHex: data && data.colorHex ? data.colorHex : DEFAULT_COLOR });
      isRestoring = previousSaveFlag;
      if (!clone) return;
      applySavedSurfaceData(clone, data);
      const srcIdx = surfaceOrder.indexOf(surfaceId);
      if (srcIdx !== -1) {
        const cloneIdx = surfaceOrder.indexOf(clone.id);
        if (cloneIdx !== -1) {
          surfaceOrder.splice(cloneIdx, 1);
        }
        surfaceOrder.splice(srcIdx + 1, 0, clone.id);
      }
      refreshSurfaceTitles();
      refreshSurfaceOrdering();
      refreshSurfaceList();
      saveState();
    }

    function removeSurface(surfaceId, skipFallback) {
      const surface = surfaces.get(surfaceId);
      if (!surface) return;
      if (surface === activeSurface) {
        onMouseUp();
      }

      if (surface.currentVideoUrl) {
        URL.revokeObjectURL(surface.currentVideoUrl);
      }
      if (surface.currentImageUrl) {
        URL.revokeObjectURL(surface.currentImageUrl);
      }
      surface.videoElement.pause();
      surface.videoElement.remove();
      surface.handles.forEach(handle => handle.remove());
      scene.remove(surface.mesh);
      surface.geometry.dispose();
      surface.material.dispose();
      if (surface.colorTexture) surface.colorTexture.dispose();
      if (surface.videoTexture) surface.videoTexture.dispose();
      if (surface.imageTexture && !surface.usingPlaceholderImage) surface.imageTexture.dispose();
      if (surface.effectTexture) surface.effectTexture.dispose();
      if (surface.animationTexture) surface.animationTexture.dispose();
      if (surface.ui && surface.ui.block) {
        surface.ui.block.remove();
      }

      surfaces.delete(surfaceId);
      const index = surfaceOrder.indexOf(surfaceId);
      if (index > -1) {
        surfaceOrder.splice(index, 1);
      }

      refreshSurfaceTitles();
      refreshSurfaceOrdering();
      refreshSurfaceList();

      if (!isRestoring) {
        saveState();
        if (!skipFallback && surfaceOrder.length === 0) {
          createSurface();
        }
      }
    }

    let activeSurface = null;
    let activeHandleIndex = null;
    let dragStartActivePositions = null;
    let dragStartActiveQuad = null;
    let dragStartAllPositions = null;
    let dragMode = null; // 'handle' of 'whole'
    let dragStartPointer = null;

    function onMouseDown(event) {
      const target = event.target;
      if (target.closest('#controls')) return;

      const rect = app.getBoundingClientRect();
      let x = event.clientX - rect.left;
      let y = event.clientY - rect.top;
      x = Math.max(0, Math.min(width, x));
      y = Math.max(0, Math.min(height, y));
      const worldX = x;
      const worldY = height - y;

      if (target.classList.contains('handle')) {
        const surfaceId = target.dataset.surface;
        const surface = surfaces.get(surfaceId);
        if (!surface) return;

        event.preventDefault();
        dragMode = 'handle';
        activeSurface = surface;
        activeHandleIndex = parseInt(target.dataset.index, 10);
      } else {
        const picked = pickSurfaceAtScreen(x, y);
        if (!picked) return;
        dragMode = 'whole';
        activeSurface = picked;
        activeHandleIndex = null;
      }

      if (!activeSurface) return;

      dragStartPointer = { x: worldX, y: worldY };
      dragStartActivePositions = new Float32Array(activeSurface.geometry.getAttribute('position').array);
      dragStartActiveQuad = positionsToQuad(dragStartActivePositions);
      dragStartAllPositions = null;
      if (linkAllSurfaces) {
        dragStartAllPositions = new Map();
        surfaces.forEach((s, id) => {
          const arr = s.geometry.getAttribute('position').array;
          dragStartAllPositions.set(id, new Float32Array(arr));
        });
      }

      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);

      if (activeSurface.currentMedia === 'video') {
        activeSurface.videoElement.play().catch(() => {});
      }
    }

    function onMouseMove(event) {
      if (!activeSurface || !dragMode) return;
      const rect = app.getBoundingClientRect();
      let x = event.clientX - rect.left;
      let y = event.clientY - rect.top;
      x = Math.max(0, Math.min(width, x));
      y = Math.max(0, Math.min(height, y));
      const worldX = x;
      const worldY = height - y;

      if (dragMode === 'handle' && activeHandleIndex !== null) {
        const targetPositions = dragStartActivePositions
          ? new Float32Array(dragStartActivePositions)
          : new Float32Array(activeSurface.geometry.getAttribute('position').array);
        const i = activeHandleIndex * 3;
        targetPositions[i] = worldX;
        targetPositions[i + 1] = worldY;

        if (linkAllSurfaces && dragStartActiveQuad && dragStartAllPositions) {
          const newQuad = positionsToQuad(targetPositions);
          const transform = solveHomographyQuadToQuad(dragStartActiveQuad, newQuad);
          if (transform) {
            surfaces.forEach((surface, id) => {
              const basePositions = dragStartAllPositions.get(id);
              if (!basePositions) return;
              const updatedPositions = applyHomographyToPositions(transform, basePositions);
              applyPositionsToGeometry(surface.geometry, updatedPositions);
              setHandlesFromGeometry(surface);
              updateHomography(surface);
            });
            return;
          }
        }

        applyPositionsToGeometry(activeSurface.geometry, targetPositions);
        setHandlesFromGeometry(activeSurface);
        updateHomography(activeSurface);
        return;
      }

      if (dragMode === 'whole' && dragStartPointer) {
        const dx = worldX - dragStartPointer.x;
        const dy = worldY - dragStartPointer.y;
        if (linkAllSurfaces && dragStartAllPositions) {
          surfaces.forEach((surface, id) => {
            const basePositions = dragStartAllPositions.get(id);
            if (!basePositions) return;
            const translated = new Float32Array(basePositions.length);
            for (let i = 0; i < basePositions.length; i += 3) {
              translated[i] = basePositions[i] + dx;
              translated[i + 1] = basePositions[i + 1] + dy;
              translated[i + 2] = 0;
            }
            applyPositionsToGeometry(surface.geometry, translated);
            setHandlesFromGeometry(surface);
            updateHomography(surface);
          });
        } else {
          const translated = new Float32Array(dragStartActivePositions.length);
          for (let i = 0; i < dragStartActivePositions.length; i += 3) {
            translated[i] = dragStartActivePositions[i] + dx;
            translated[i + 1] = dragStartActivePositions[i + 1] + dy;
            translated[i + 2] = 0;
          }
          applyPositionsToGeometry(activeSurface.geometry, translated);
          setHandlesFromGeometry(activeSurface);
          updateHomography(activeSurface);
        }
      }
    }

    function onMouseUp() {
      const surface = activeSurface;
      activeSurface = null;
      activeHandleIndex = null;
      dragStartActivePositions = null;
      dragStartActiveQuad = null;
      dragStartAllPositions = null;
      dragStartPointer = null;
      dragMode = null;
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);
      if (surface && surface.currentMedia === 'effect' && surface.effectName) {
        applyEffectToSurface(surface, surface.effectName, { force: true });
      }
      if (surface && surface.currentMedia === 'animation' && surface.animationName) {
        applyAnimationToSurface(surface, surface.animationName, { force: true });
      }
      if (surface) {
        saveState();
      }
    }

    app.addEventListener('mousedown', onMouseDown);

    addContentBtn.addEventListener('click', () => {
      createSurface();
    });


      if (undoBtn) {
        undoBtn.addEventListener('click', () => {
          undoHistory();
        });
      }

      if (redoBtn) {
        redoBtn.addEventListener('click', () => {
          redoHistory();
        });
      }
    if (linkAllToggle) {
      linkAllToggle.addEventListener('click', () => {
        linkAllSurfaces = !linkAllSurfaces;
        syncLinkAllToggle();
        saveState();
      });
    }

    playBtn.addEventListener('click', () => {
      surfaces.forEach(surface => {
        surface.videoElement.play().catch(() => {});
      });
    });

    window.addEventListener('resize', () => {
      width = app.clientWidth;
      height = app.clientHeight;
      const devicePixelRatio = Math.min(2, window.devicePixelRatio || 1);
      renderer.setPixelRatio(devicePixelRatio);
      renderer.setSize(width, height, false);
      surfaces.forEach(surface => {
        updateHomography(surface);
      });
      saveState();
    });

    function animate() {
      requestAnimationFrame(animate);
      const now = performance.now();
      surfaces.forEach(surface => {
        if (surface.currentMedia === 'video' && surface.videoElement.readyState >= surface.videoElement.HAVE_CURRENT_DATA) {
          surface.videoTexture.needsUpdate = true;
        }
        if (surface.currentMedia === 'effect' && surface.effectDefinition && surface.effectCtx) {
          surface.effectDefinition.draw(surface.effectCtx, now - surface.effectStartTime);
          if (surface.effectTexture) {
            surface.effectTexture.needsUpdate = true;
          }
        }
        if (surface.currentMedia === 'animation' && surface.animationDefinition && surface.animationCtx) {
          surface.animationDefinition.draw(surface.animationCtx, now - surface.animationStartTime);
          if (surface.animationTexture) {
            surface.animationTexture.needsUpdate = true;
          }
        }
      });
      renderer.render(scene, camera);
    }

    loadState();
    if (surfaceOrder.length === 0) {
      createSurface();
    }
    animate();
  </script>
</body>
</html>